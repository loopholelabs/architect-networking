// Package client provides primitives to interact with the Conduit HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

// Defines values for DDoSStatusMaxBlockedIPs.
const (
	N10000 DDoSStatusMaxBlockedIPs = 10000
)

// Defines values for ICMPFirewallStatusMaxRules.
const (
	ICMPFirewallStatusMaxRulesN256 ICMPFirewallStatusMaxRules = 256
)

// Defines values for TCPFirewallStatusMaxRules.
const (
	TCPFirewallStatusMaxRulesN256 TCPFirewallStatusMaxRules = 256
)

// Defines values for UDPFirewallStatusMaxRules.
const (
	N256 UDPFirewallStatusMaxRules = 256
)

// DDoSConfig Configuration for DDoS protection settings.
// Used to enable or disable DDoS protection on the dataplane.
type DDoSConfig struct {
	// Enabled Whether DDoS protection should be enabled (true) or disabled (false).
	// When disabled, no IP addresses will be blocked regardless of the blocked IP list.
	Enabled bool `json:"enabled"`
}

// DDoSStatus Current status and statistics for DDoS protection.
// Provides comprehensive information about the protection state and capacity usage.
type DDoSStatus struct {
	// BlockedIPCount Current number of IP addresses in the DDoS block list.
	// This includes all IPs added via the API or initial configuration.
	BlockedIPCount uint64 `json:"blockedIPCount"`

	// Enabled Whether DDoS protection is currently enabled (true) or disabled (false).
	// When disabled, blocked IPs are maintained but not actively blocking traffic.
	Enabled bool `json:"enabled"`

	// MaxBlockedIPs Maximum number of IP addresses that can be blocked simultaneously.
	// Currently fixed at 10,000 addresses for performance reasons.
	MaxBlockedIPs DDoSStatusMaxBlockedIPs `json:"maxBlockedIPs"`
}

// DDoSStatusMaxBlockedIPs Maximum number of IP addresses that can be blocked simultaneously.
// Currently fixed at 10,000 addresses for performance reasons.
type DDoSStatusMaxBlockedIPs uint64

// FirewallConfig Configuration for firewall settings.
// Used to enable or disable firewall protection components.
type FirewallConfig struct {
	// Enabled Whether firewall protection should be enabled (true) or disabled (false).
	// When disabled, no traffic will be blocked regardless of configured rules.
	Enabled bool `json:"enabled"`
}

// FirewallStatus Current status and statistics for all firewall components.
// Provides comprehensive information about ICMP, TCP, and UDP firewall states.
type FirewallStatus struct {
	// Icmp Current status and statistics for ICMP firewall component.
	// ICMP firewall blocks ping, traceroute, and other ICMP traffic.
	Icmp ICMPFirewallStatus `json:"icmp"`

	// Tcp Current status and statistics for TCP firewall component.
	// TCP firewall blocks TCP connections based on IP and port rules.
	Tcp TCPFirewallStatus `json:"tcp"`

	// Udp Current status and statistics for UDP firewall component.
	// UDP firewall blocks UDP traffic based on IP and port rules.
	Udp UDPFirewallStatus `json:"udp"`
}

// ICMPFirewallRule Firewall rule for blocking ICMP traffic based on IP addresses.
// ICMP rules specify source and/or destination IP ranges in CIDR notation.
// At least one of source or destination must be specified.
type ICMPFirewallRule struct {
	// Destination Destination IP address or CIDR range to match against.
	// If null, the rule matches any destination IP address.
	// Examples: "8.8.8.8/32" (single IP), "10.0.0.0/16" (subnet)
	Destination *string `json:"destination"`

	// Source Source IP address or CIDR range to match against.
	// If null, the rule matches any source IP address.
	// Examples: "192.168.1.10/32" (single IP), "10.0.0.0/8" (subnet)
	Source *string `json:"source"`
	union  json.RawMessage
}

// ICMPFirewallRule0 defines model for .
type ICMPFirewallRule0 = interface{}

// ICMPFirewallRule1 defines model for .
type ICMPFirewallRule1 = interface{}

// ICMPFirewallRuleResponse Response when an ICMP firewall rule is successfully created.
// Contains the assigned rule ID and current firewall status.
type ICMPFirewallRuleResponse struct {
	// RuleId Unique identifier assigned to the created ICMP firewall rule.
	// Use this ID to remove the rule later.
	RuleId uint8 `json:"ruleId"`

	// Status Current status and statistics for ICMP firewall component.
	// ICMP firewall blocks ping, traceroute, and other ICMP traffic.
	Status ICMPFirewallStatus `json:"status"`
}

// ICMPFirewallStatus Current status and statistics for ICMP firewall component.
// ICMP firewall blocks ping, traceroute, and other ICMP traffic.
type ICMPFirewallStatus struct {
	// Enabled Whether ICMP firewall is currently enabled (true) or disabled (false).
	// When disabled, ICMP rules are maintained but not actively blocking traffic.
	Enabled bool `json:"enabled"`

	// MaxRules Maximum number of ICMP firewall rules that can be configured.
	// Currently fixed at 256 rules for performance reasons.
	MaxRules ICMPFirewallStatusMaxRules `json:"maxRules"`

	// RuleCount Current number of ICMP firewall rules configured.
	RuleCount uint32 `json:"ruleCount"`
}

// ICMPFirewallStatusMaxRules Maximum number of ICMP firewall rules that can be configured.
// Currently fixed at 256 rules for performance reasons.
type ICMPFirewallStatusMaxRules uint32

// NATBitmapPair Represents port allocation information using bitmaps for efficient
// port management. Each bit in the bitmap represents whether a specific
// port is allocated or available on a given IP address.
type NATBitmapPair struct {
	// Bitmap Binary representation of port allocations as a string.
	// Each bit represents a port: '1' = allocated, '0' = available.
	// The bitmap covers a range of ports, with position indicating port offset.
	Bitmap string `json:"Bitmap"`

	// DestinationIP Optional destination IP address for destination-specific port allocations.
	// When null, the bitmap applies to all destinations for the NATIP.
	// This allows for more granular port management per destination.
	DestinationIP *string `json:"DestinationIP"`

	// LastChunk The last chunk index used for port allocation optimization.
	// Helps track which section of the port space was most recently allocated,
	// improving allocation performance by avoiding full bitmap scans.
	LastChunk uint16 `json:"LastChunk"`

	// NATIP The NAT IP address that this port bitmap applies to.
	// This must be one of the IPs allocated to the dataplane.
	NATIP string `json:"NATIP"`
}

// NATKey Represents the unique identifier (key) for a NAT translation entry.
// This key combines the original source and destination address/port pairs
// to uniquely identify a network flow requiring translation.
type NATKey struct {
	// DestinationIP The destination IP address that the packet is being sent to.
	// This is typically an external/public IP address.
	DestinationIP string `json:"DestinationIP"`

	// DestinationPort The destination port number that the packet is being sent to.
	// Common examples include 80 (HTTP), 443 (HTTPS), 53 (DNS).
	DestinationPort uint16 `json:"DestinationPort"`

	// SourceIP The original source IP address of the packet before NAT translation.
	// This is typically an internal/private IP address.
	SourceIP string `json:"SourceIP"`

	// SourcePort The original source port number before NAT translation.
	// Valid range is 1-65535.
	SourcePort uint16 `json:"SourcePort"`
}

// NATKeyValuePair Represents a complete NAT translation entry, combining the unique identifier
// (key) with the translation information (value). This is the fundamental
// data structure for active NAT translations.
type NATKeyValuePair struct {
	// Key Represents the unique identifier (key) for a NAT translation entry.
	// This key combines the original source and destination address/port pairs
	// to uniquely identify a network flow requiring translation.
	Key NATKey `json:"Key"`

	// Value Contains the translated network information and metadata for a NAT entry.
	// This represents what the original source address/port should be translated
	// to when performing NAT operations.
	Value NATValue `json:"Value"`
}

// NATState Represents the complete state of all NAT tables in the dataplane.
// This comprehensive structure contains all active translations,
// port allocations, and IP assignments required for NAT operations.
//
// **Structure Overview:**
// - **IPs**: All IP addresses allocated to the dataplane
// - **Protocol Tables**: Separate tables for TCP and UDP, each with inbound/outbound directions
// - **Port Management**: Bitmap-based port allocation tracking
//
// **Direction Definitions:**
// - **Inbound**: Traffic coming into the dataplane from external sources
// - **Outbound**: Traffic originating from internal sources going through the dataplane
type NATState struct {
	// IPs Complete list of IPv4 addresses allocated to the dataplane.
	// These addresses are available for use in NAT translations
	// and must be allocated before being used in translation entries.
	IPs []string `json:"IPs"`

	// NATPorts Port allocation bitmaps for efficient port management.
	// Each entry tracks which ports are allocated/available on specific IP addresses,
	// enabling fast port allocation and deallocation operations.
	NATPorts []NATBitmapPair `json:"NATPorts"`

	// TCPInbound Active NAT translation entries for inbound TCP connections.
	// These represent external clients connecting to services behind the NAT.
	TCPInbound []NATKeyValuePair `json:"TCPInbound"`

	// TCPOutbound Active NAT translation entries for outbound TCP connections.
	// These represent internal clients connecting to external services.
	TCPOutbound []NATKeyValuePair `json:"TCPOutbound"`

	// UDPInbound Active NAT translation entries for inbound UDP traffic.
	// These represent external sources sending UDP packets to services behind the NAT.
	UDPInbound []NATKeyValuePair `json:"UDPInbound"`

	// UDPOutbound Active NAT translation entries for outbound UDP traffic.
	// These represent internal sources sending UDP packets to external destinations.
	UDPOutbound []NATKeyValuePair `json:"UDPOutbound"`
}

// NATValue Contains the translated network information and metadata for a NAT entry.
// This represents what the original source address/port should be translated
// to when performing NAT operations.
type NATValue struct {
	// LastSeen Timestamp of when this NAT entry was last used, expressed as
	// nanoseconds since Unix epoch (January 1, 1970 UTC).
	// Used for tracking entry age and garbage collection of stale entries.
	LastSeen string `json:"LastSeen"`

	// TranslateIP The IP address to translate the original source IP to.
	// This is typically one of the dataplane's allocated IP addresses
	// and represents the public-facing IP for the translation.
	TranslateIP string `json:"TranslateIP"`

	// TranslatePort The port number to translate the original source port to.
	// This port is allocated from the available port pool on the TranslateIP.
	// Valid range is 1-65535.
	TranslatePort uint16 `json:"TranslatePort"`
}

// RouterStatus Complete status of the router including all subsystem states and configuration.
// Provides a comprehensive view of the router's operational state.
type RouterStatus struct {
	// Enabled Whether the router is globally enabled. When false, no routing
	// operations are performed regardless of other settings.
	Enabled bool `json:"enabled"`

	// InboundNATEnabled Whether inbound NAT (destination NAT) is currently enabled.
	// Requires router to be enabled and NAT IPs configured.
	InboundNATEnabled bool `json:"inboundNATEnabled"`

	// InterfacesEnabled Whether the router is processing packets on network interfaces.
	// When false, router ignores all network traffic.
	InterfacesEnabled bool `json:"interfacesEnabled"`

	// NatIPs List of IP addresses currently allocated to the router for NAT operations.
	// These IPs are used for both inbound and outbound translations.
	NatIPs []string `json:"natIPs"`

	// OutboundNATEnabled Whether outbound NAT (source NAT) is currently enabled.
	// Requires router to be enabled and at least one NAT IP configured.
	OutboundNATEnabled bool `json:"outboundNATEnabled"`
}

// TCPFirewallRule Firewall rule for blocking TCP connections based on IP addresses and ports.
// TCP rules specify source/destination IP ranges and port ranges.
// At least one of source or destination IP must be specified.
type TCPFirewallRule struct {
	// Destination Destination IP address or CIDR range to match against.
	// If null, the rule matches any destination IP address.
	Destination *string `json:"destination"`

	// DestinationPortHigh Upper bound of the destination port range to match against.
	// Must be >= destinationPortLow. Use same value to match a single port.
	DestinationPortHigh *uint16 `json:"destinationPortHigh,omitempty"`

	// DestinationPortLow Lower bound of the destination port range to match against.
	// Must be <= destinationPortHigh. Use same value to match a single port.
	DestinationPortLow *uint16 `json:"destinationPortLow,omitempty"`

	// Source Source IP address or CIDR range to match against.
	// If null, the rule matches any source IP address.
	Source *string `json:"source"`

	// SourcePortHigh Upper bound of the source port range to match against.
	// Must be >= sourcePortLow. Use same value for both to match a single port.
	SourcePortHigh *uint16 `json:"sourcePortHigh,omitempty"`

	// SourcePortLow Lower bound of the source port range to match against.
	// Must be <= sourcePortHigh. Use same value for both to match a single port.
	SourcePortLow *uint16 `json:"sourcePortLow,omitempty"`
	union         json.RawMessage
}

// TCPFirewallRule0 defines model for .
type TCPFirewallRule0 = interface{}

// TCPFirewallRule1 defines model for .
type TCPFirewallRule1 = interface{}

// TCPFirewallRuleResponse Response when a TCP firewall rule is successfully created.
// Contains the assigned rule ID and current firewall status.
type TCPFirewallRuleResponse struct {
	// RuleId Unique identifier assigned to the created TCP firewall rule.
	// Use this ID to remove the rule later.
	RuleId uint8 `json:"ruleId"`

	// Status Current status and statistics for TCP firewall component.
	// TCP firewall blocks TCP connections based on IP and port rules.
	Status TCPFirewallStatus `json:"status"`
}

// TCPFirewallStatus Current status and statistics for TCP firewall component.
// TCP firewall blocks TCP connections based on IP and port rules.
type TCPFirewallStatus struct {
	// Enabled Whether TCP firewall is currently enabled (true) or disabled (false).
	// When disabled, TCP rules are maintained but not actively blocking traffic.
	Enabled bool `json:"enabled"`

	// MaxRules Maximum number of TCP firewall rules that can be configured.
	// Currently fixed at 256 rules for performance reasons.
	MaxRules TCPFirewallStatusMaxRules `json:"maxRules"`

	// RuleCount Current number of TCP firewall rules configured.
	RuleCount uint32 `json:"ruleCount"`
}

// TCPFirewallStatusMaxRules Maximum number of TCP firewall rules that can be configured.
// Currently fixed at 256 rules for performance reasons.
type TCPFirewallStatusMaxRules uint32

// UDPFirewallRule Firewall rule for blocking UDP traffic based on IP addresses and ports.
// UDP rules specify source/destination IP ranges and port ranges.
// At least one of source or destination IP must be specified.
type UDPFirewallRule struct {
	// Destination Destination IP address or CIDR range to match against.
	// If null, the rule matches any destination IP address.
	Destination *string `json:"destination"`

	// DestinationPortHigh Upper bound of the destination port range to match against.
	// Must be >= destinationPortLow. Use same value to match a single port.
	DestinationPortHigh *uint16 `json:"destinationPortHigh,omitempty"`

	// DestinationPortLow Lower bound of the destination port range to match against.
	// Must be <= destinationPortHigh. Use same value to match a single port.
	DestinationPortLow *uint16 `json:"destinationPortLow,omitempty"`

	// Source Source IP address or CIDR range to match against.
	// If null, the rule matches any source IP address.
	Source *string `json:"source"`

	// SourcePortHigh Upper bound of the source port range to match against.
	// Must be >= sourcePortLow. Use same value for both to match a single port.
	SourcePortHigh *uint16 `json:"sourcePortHigh,omitempty"`

	// SourcePortLow Lower bound of the source port range to match against.
	// Must be <= sourcePortHigh. Use same value for both to match a single port.
	SourcePortLow *uint16 `json:"sourcePortLow,omitempty"`
	union         json.RawMessage
}

// UDPFirewallRule0 defines model for .
type UDPFirewallRule0 = interface{}

// UDPFirewallRule1 defines model for .
type UDPFirewallRule1 = interface{}

// UDPFirewallRuleResponse Response when a UDP firewall rule is successfully created.
// Contains the assigned rule ID and current firewall status.
type UDPFirewallRuleResponse struct {
	// RuleId Unique identifier assigned to the created UDP firewall rule.
	// Use this ID to remove the rule later.
	RuleId uint8 `json:"ruleId"`

	// Status Current status and statistics for UDP firewall component.
	// UDP firewall blocks UDP traffic based on IP and port rules.
	Status UDPFirewallStatus `json:"status"`
}

// UDPFirewallStatus Current status and statistics for UDP firewall component.
// UDP firewall blocks UDP traffic based on IP and port rules.
type UDPFirewallStatus struct {
	// Enabled Whether UDP firewall is currently enabled (true) or disabled (false).
	// When disabled, UDP rules are maintained but not actively blocking traffic.
	Enabled bool `json:"enabled"`

	// MaxRules Maximum number of UDP firewall rules that can be configured.
	// Currently fixed at 256 rules for performance reasons.
	MaxRules UDPFirewallStatusMaxRules `json:"maxRules"`

	// RuleCount Current number of UDP firewall rules configured.
	RuleCount uint32 `json:"ruleCount"`
}

// UDPFirewallStatusMaxRules Maximum number of UDP firewall rules that can be configured.
// Currently fixed at 256 rules for performance reasons.
type UDPFirewallStatusMaxRules uint32

// AddDDoSIPParams defines parameters for AddDDoSIP.
type AddDDoSIPParams struct {
	// Ip The IPv4 address to add to the DDoS block list. Must be a valid IPv4 address
	// in dotted decimal notation (e.g., "192.0.2.1").
	Ip string `form:"ip" json:"ip"`
}

// DeleteIPParams defines parameters for DeleteIP.
type DeleteIPParams struct {
	// Ip The IPv4 address to remove from the dataplane. Must be a valid IPv4 address
	// that is currently allocated to the dataplane.
	Ip string `form:"ip" json:"ip"`
}

// CreateIPParams defines parameters for CreateIP.
type CreateIPParams struct {
	// Ip The IPv4 address to allocate to the dataplane. Must be a valid IPv4 address
	// in dotted decimal notation (e.g., "192.168.1.100").
	Ip string `form:"ip" json:"ip"`
}

// SetRouterInterfacesJSONBody defines parameters for SetRouterInterfaces.
type SetRouterInterfacesJSONBody struct {
	// Enabled Whether to enable or disable router interfaces
	Enabled bool `json:"enabled"`
}

// SetInboundNATJSONBody defines parameters for SetInboundNAT.
type SetInboundNATJSONBody struct {
	// Enabled Whether to enable or disable inbound NAT
	Enabled bool `json:"enabled"`
}

// SetOutboundNATJSONBody defines parameters for SetOutboundNAT.
type SetOutboundNATJSONBody struct {
	// Enabled Whether to enable or disable outbound NAT
	Enabled bool `json:"enabled"`
}

// SetDDoSEnabledJSONRequestBody defines body for SetDDoSEnabled for application/json ContentType.
type SetDDoSEnabledJSONRequestBody = DDoSConfig

// SetFirewallEnabledJSONRequestBody defines body for SetFirewallEnabled for application/json ContentType.
type SetFirewallEnabledJSONRequestBody = FirewallConfig

// SetICMPFirewallEnabledJSONRequestBody defines body for SetICMPFirewallEnabled for application/json ContentType.
type SetICMPFirewallEnabledJSONRequestBody = FirewallConfig

// AddICMPFirewallRuleJSONRequestBody defines body for AddICMPFirewallRule for application/json ContentType.
type AddICMPFirewallRuleJSONRequestBody = ICMPFirewallRule

// SetTCPFirewallEnabledJSONRequestBody defines body for SetTCPFirewallEnabled for application/json ContentType.
type SetTCPFirewallEnabledJSONRequestBody = FirewallConfig

// AddTCPFirewallRuleJSONRequestBody defines body for AddTCPFirewallRule for application/json ContentType.
type AddTCPFirewallRuleJSONRequestBody = TCPFirewallRule

// SetUDPFirewallEnabledJSONRequestBody defines body for SetUDPFirewallEnabled for application/json ContentType.
type SetUDPFirewallEnabledJSONRequestBody = FirewallConfig

// AddUDPFirewallRuleJSONRequestBody defines body for AddUDPFirewallRule for application/json ContentType.
type AddUDPFirewallRuleJSONRequestBody = UDPFirewallRule

// SetRouterInterfacesJSONRequestBody defines body for SetRouterInterfaces for application/json ContentType.
type SetRouterInterfacesJSONRequestBody SetRouterInterfacesJSONBody

// SetInboundNATJSONRequestBody defines body for SetInboundNAT for application/json ContentType.
type SetInboundNATJSONRequestBody SetInboundNATJSONBody

// SetOutboundNATJSONRequestBody defines body for SetOutboundNAT for application/json ContentType.
type SetOutboundNATJSONRequestBody SetOutboundNATJSONBody

// SetStateJSONRequestBody defines body for SetState for application/json ContentType.
type SetStateJSONRequestBody = NATState

// AsICMPFirewallRule0 returns the union data inside the ICMPFirewallRule as a ICMPFirewallRule0
func (t ICMPFirewallRule) AsICMPFirewallRule0() (ICMPFirewallRule0, error) {
	var body ICMPFirewallRule0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromICMPFirewallRule0 overwrites any union data inside the ICMPFirewallRule as the provided ICMPFirewallRule0
func (t *ICMPFirewallRule) FromICMPFirewallRule0(v ICMPFirewallRule0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeICMPFirewallRule0 performs a merge with any union data inside the ICMPFirewallRule, using the provided ICMPFirewallRule0
func (t *ICMPFirewallRule) MergeICMPFirewallRule0(v ICMPFirewallRule0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsICMPFirewallRule1 returns the union data inside the ICMPFirewallRule as a ICMPFirewallRule1
func (t ICMPFirewallRule) AsICMPFirewallRule1() (ICMPFirewallRule1, error) {
	var body ICMPFirewallRule1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromICMPFirewallRule1 overwrites any union data inside the ICMPFirewallRule as the provided ICMPFirewallRule1
func (t *ICMPFirewallRule) FromICMPFirewallRule1(v ICMPFirewallRule1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeICMPFirewallRule1 performs a merge with any union data inside the ICMPFirewallRule, using the provided ICMPFirewallRule1
func (t *ICMPFirewallRule) MergeICMPFirewallRule1(v ICMPFirewallRule1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ICMPFirewallRule) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Destination != nil {
		object["destination"], err = json.Marshal(t.Destination)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'destination': %w", err)
		}
	}

	if t.Source != nil {
		object["source"], err = json.Marshal(t.Source)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'source': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *ICMPFirewallRule) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["destination"]; found {
		err = json.Unmarshal(raw, &t.Destination)
		if err != nil {
			return fmt.Errorf("error reading 'destination': %w", err)
		}
	}

	if raw, found := object["source"]; found {
		err = json.Unmarshal(raw, &t.Source)
		if err != nil {
			return fmt.Errorf("error reading 'source': %w", err)
		}
	}

	return err
}

// AsTCPFirewallRule0 returns the union data inside the TCPFirewallRule as a TCPFirewallRule0
func (t TCPFirewallRule) AsTCPFirewallRule0() (TCPFirewallRule0, error) {
	var body TCPFirewallRule0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTCPFirewallRule0 overwrites any union data inside the TCPFirewallRule as the provided TCPFirewallRule0
func (t *TCPFirewallRule) FromTCPFirewallRule0(v TCPFirewallRule0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTCPFirewallRule0 performs a merge with any union data inside the TCPFirewallRule, using the provided TCPFirewallRule0
func (t *TCPFirewallRule) MergeTCPFirewallRule0(v TCPFirewallRule0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTCPFirewallRule1 returns the union data inside the TCPFirewallRule as a TCPFirewallRule1
func (t TCPFirewallRule) AsTCPFirewallRule1() (TCPFirewallRule1, error) {
	var body TCPFirewallRule1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTCPFirewallRule1 overwrites any union data inside the TCPFirewallRule as the provided TCPFirewallRule1
func (t *TCPFirewallRule) FromTCPFirewallRule1(v TCPFirewallRule1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTCPFirewallRule1 performs a merge with any union data inside the TCPFirewallRule, using the provided TCPFirewallRule1
func (t *TCPFirewallRule) MergeTCPFirewallRule1(v TCPFirewallRule1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TCPFirewallRule) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Destination != nil {
		object["destination"], err = json.Marshal(t.Destination)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'destination': %w", err)
		}
	}

	if t.DestinationPortHigh != nil {
		object["destinationPortHigh"], err = json.Marshal(t.DestinationPortHigh)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'destinationPortHigh': %w", err)
		}
	}

	if t.DestinationPortLow != nil {
		object["destinationPortLow"], err = json.Marshal(t.DestinationPortLow)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'destinationPortLow': %w", err)
		}
	}

	if t.Source != nil {
		object["source"], err = json.Marshal(t.Source)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'source': %w", err)
		}
	}

	if t.SourcePortHigh != nil {
		object["sourcePortHigh"], err = json.Marshal(t.SourcePortHigh)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sourcePortHigh': %w", err)
		}
	}

	if t.SourcePortLow != nil {
		object["sourcePortLow"], err = json.Marshal(t.SourcePortLow)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sourcePortLow': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *TCPFirewallRule) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["destination"]; found {
		err = json.Unmarshal(raw, &t.Destination)
		if err != nil {
			return fmt.Errorf("error reading 'destination': %w", err)
		}
	}

	if raw, found := object["destinationPortHigh"]; found {
		err = json.Unmarshal(raw, &t.DestinationPortHigh)
		if err != nil {
			return fmt.Errorf("error reading 'destinationPortHigh': %w", err)
		}
	}

	if raw, found := object["destinationPortLow"]; found {
		err = json.Unmarshal(raw, &t.DestinationPortLow)
		if err != nil {
			return fmt.Errorf("error reading 'destinationPortLow': %w", err)
		}
	}

	if raw, found := object["source"]; found {
		err = json.Unmarshal(raw, &t.Source)
		if err != nil {
			return fmt.Errorf("error reading 'source': %w", err)
		}
	}

	if raw, found := object["sourcePortHigh"]; found {
		err = json.Unmarshal(raw, &t.SourcePortHigh)
		if err != nil {
			return fmt.Errorf("error reading 'sourcePortHigh': %w", err)
		}
	}

	if raw, found := object["sourcePortLow"]; found {
		err = json.Unmarshal(raw, &t.SourcePortLow)
		if err != nil {
			return fmt.Errorf("error reading 'sourcePortLow': %w", err)
		}
	}

	return err
}

// AsUDPFirewallRule0 returns the union data inside the UDPFirewallRule as a UDPFirewallRule0
func (t UDPFirewallRule) AsUDPFirewallRule0() (UDPFirewallRule0, error) {
	var body UDPFirewallRule0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUDPFirewallRule0 overwrites any union data inside the UDPFirewallRule as the provided UDPFirewallRule0
func (t *UDPFirewallRule) FromUDPFirewallRule0(v UDPFirewallRule0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUDPFirewallRule0 performs a merge with any union data inside the UDPFirewallRule, using the provided UDPFirewallRule0
func (t *UDPFirewallRule) MergeUDPFirewallRule0(v UDPFirewallRule0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUDPFirewallRule1 returns the union data inside the UDPFirewallRule as a UDPFirewallRule1
func (t UDPFirewallRule) AsUDPFirewallRule1() (UDPFirewallRule1, error) {
	var body UDPFirewallRule1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUDPFirewallRule1 overwrites any union data inside the UDPFirewallRule as the provided UDPFirewallRule1
func (t *UDPFirewallRule) FromUDPFirewallRule1(v UDPFirewallRule1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUDPFirewallRule1 performs a merge with any union data inside the UDPFirewallRule, using the provided UDPFirewallRule1
func (t *UDPFirewallRule) MergeUDPFirewallRule1(v UDPFirewallRule1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UDPFirewallRule) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Destination != nil {
		object["destination"], err = json.Marshal(t.Destination)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'destination': %w", err)
		}
	}

	if t.DestinationPortHigh != nil {
		object["destinationPortHigh"], err = json.Marshal(t.DestinationPortHigh)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'destinationPortHigh': %w", err)
		}
	}

	if t.DestinationPortLow != nil {
		object["destinationPortLow"], err = json.Marshal(t.DestinationPortLow)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'destinationPortLow': %w", err)
		}
	}

	if t.Source != nil {
		object["source"], err = json.Marshal(t.Source)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'source': %w", err)
		}
	}

	if t.SourcePortHigh != nil {
		object["sourcePortHigh"], err = json.Marshal(t.SourcePortHigh)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sourcePortHigh': %w", err)
		}
	}

	if t.SourcePortLow != nil {
		object["sourcePortLow"], err = json.Marshal(t.SourcePortLow)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sourcePortLow': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *UDPFirewallRule) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["destination"]; found {
		err = json.Unmarshal(raw, &t.Destination)
		if err != nil {
			return fmt.Errorf("error reading 'destination': %w", err)
		}
	}

	if raw, found := object["destinationPortHigh"]; found {
		err = json.Unmarshal(raw, &t.DestinationPortHigh)
		if err != nil {
			return fmt.Errorf("error reading 'destinationPortHigh': %w", err)
		}
	}

	if raw, found := object["destinationPortLow"]; found {
		err = json.Unmarshal(raw, &t.DestinationPortLow)
		if err != nil {
			return fmt.Errorf("error reading 'destinationPortLow': %w", err)
		}
	}

	if raw, found := object["source"]; found {
		err = json.Unmarshal(raw, &t.Source)
		if err != nil {
			return fmt.Errorf("error reading 'source': %w", err)
		}
	}

	if raw, found := object["sourcePortHigh"]; found {
		err = json.Unmarshal(raw, &t.SourcePortHigh)
		if err != nil {
			return fmt.Errorf("error reading 'sourcePortHigh': %w", err)
		}
	}

	if raw, found := object["sourcePortLow"]; found {
		err = json.Unmarshal(raw, &t.SourcePortLow)
		if err != nil {
			return fmt.Errorf("error reading 'sourcePortLow': %w", err)
		}
	}

	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ResetDDoS request
	ResetDDoS(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDDoSStatus request
	GetDDoSStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDDoSEnabledWithBody request with any body
	SetDDoSEnabledWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetDDoSEnabled(ctx context.Context, body SetDDoSEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddDDoSIP request
	AddDDoSIP(ctx context.Context, params *AddDDoSIPParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetFirewall request
	ResetFirewall(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFirewallStatus request
	GetFirewallStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetFirewallEnabledWithBody request with any body
	SetFirewallEnabledWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetFirewallEnabled(ctx context.Context, body SetFirewallEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetICMPFirewall request
	ResetICMPFirewall(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetICMPFirewallStatus request
	GetICMPFirewallStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetICMPFirewallEnabledWithBody request with any body
	SetICMPFirewallEnabledWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetICMPFirewallEnabled(ctx context.Context, body SetICMPFirewallEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddICMPFirewallRuleWithBody request with any body
	AddICMPFirewallRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddICMPFirewallRule(ctx context.Context, body AddICMPFirewallRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveICMPFirewallRule request
	RemoveICMPFirewallRule(ctx context.Context, ruleId uint8, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetTCPFirewall request
	ResetTCPFirewall(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTCPFirewallStatus request
	GetTCPFirewallStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetTCPFirewallEnabledWithBody request with any body
	SetTCPFirewallEnabledWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetTCPFirewallEnabled(ctx context.Context, body SetTCPFirewallEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddTCPFirewallRuleWithBody request with any body
	AddTCPFirewallRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddTCPFirewallRule(ctx context.Context, body AddTCPFirewallRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveTCPFirewallRule request
	RemoveTCPFirewallRule(ctx context.Context, ruleId uint8, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetUDPFirewall request
	ResetUDPFirewall(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUDPFirewallStatus request
	GetUDPFirewallStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetUDPFirewallEnabledWithBody request with any body
	SetUDPFirewallEnabledWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetUDPFirewallEnabled(ctx context.Context, body SetUDPFirewallEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUDPFirewallRuleWithBody request with any body
	AddUDPFirewallRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUDPFirewallRule(ctx context.Context, body AddUDPFirewallRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUDPFirewallRule request
	RemoveUDPFirewallRule(ctx context.Context, ruleId uint8, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIP request
	DeleteIP(ctx context.Context, params *DeleteIPParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIPs request
	ListIPs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIP request
	CreateIP(ctx context.Context, params *CreateIPParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRouterInterfacesWithBody request with any body
	SetRouterInterfacesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetRouterInterfaces(ctx context.Context, body SetRouterInterfacesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetInboundNATWithBody request with any body
	SetInboundNATWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetInboundNAT(ctx context.Context, body SetInboundNATJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetOutboundNATWithBody request with any body
	SetOutboundNATWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetOutboundNAT(ctx context.Context, body SetOutboundNATJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRouterStatus request
	GetRouterStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetState request
	GetState(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetStateWithBody request with any body
	SetStateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetState(ctx context.Context, body SetStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ResetDDoS(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetDDoSRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDDoSStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDDoSStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDDoSEnabledWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDDoSEnabledRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDDoSEnabled(ctx context.Context, body SetDDoSEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDDoSEnabledRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDDoSIP(ctx context.Context, params *AddDDoSIPParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDDoSIPRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetFirewall(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetFirewallRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFirewallStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFirewallStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetFirewallEnabledWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetFirewallEnabledRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetFirewallEnabled(ctx context.Context, body SetFirewallEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetFirewallEnabledRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetICMPFirewall(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetICMPFirewallRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetICMPFirewallStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetICMPFirewallStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetICMPFirewallEnabledWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetICMPFirewallEnabledRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetICMPFirewallEnabled(ctx context.Context, body SetICMPFirewallEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetICMPFirewallEnabledRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddICMPFirewallRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddICMPFirewallRuleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddICMPFirewallRule(ctx context.Context, body AddICMPFirewallRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddICMPFirewallRuleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveICMPFirewallRule(ctx context.Context, ruleId uint8, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveICMPFirewallRuleRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetTCPFirewall(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetTCPFirewallRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTCPFirewallStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTCPFirewallStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetTCPFirewallEnabledWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetTCPFirewallEnabledRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetTCPFirewallEnabled(ctx context.Context, body SetTCPFirewallEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetTCPFirewallEnabledRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTCPFirewallRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTCPFirewallRuleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTCPFirewallRule(ctx context.Context, body AddTCPFirewallRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTCPFirewallRuleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTCPFirewallRule(ctx context.Context, ruleId uint8, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTCPFirewallRuleRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetUDPFirewall(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetUDPFirewallRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUDPFirewallStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUDPFirewallStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetUDPFirewallEnabledWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetUDPFirewallEnabledRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetUDPFirewallEnabled(ctx context.Context, body SetUDPFirewallEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetUDPFirewallEnabledRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUDPFirewallRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUDPFirewallRuleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUDPFirewallRule(ctx context.Context, body AddUDPFirewallRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUDPFirewallRuleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUDPFirewallRule(ctx context.Context, ruleId uint8, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUDPFirewallRuleRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIP(ctx context.Context, params *DeleteIPParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIPRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIPs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIPsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIP(ctx context.Context, params *CreateIPParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIPRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRouterInterfacesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRouterInterfacesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRouterInterfaces(ctx context.Context, body SetRouterInterfacesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRouterInterfacesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetInboundNATWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetInboundNATRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetInboundNAT(ctx context.Context, body SetInboundNATJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetInboundNATRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetOutboundNATWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetOutboundNATRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetOutboundNAT(ctx context.Context, body SetOutboundNATJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetOutboundNATRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRouterStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRouterStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetState(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetStateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetStateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetState(ctx context.Context, body SetStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetStateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewResetDDoSRequest generates requests for ResetDDoS
func NewResetDDoSRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/ddos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDDoSStatusRequest generates requests for GetDDoSStatus
func NewGetDDoSStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/ddos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDDoSEnabledRequest calls the generic SetDDoSEnabled builder with application/json body
func NewSetDDoSEnabledRequest(server string, body SetDDoSEnabledJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetDDoSEnabledRequestWithBody(server, "application/json", bodyReader)
}

// NewSetDDoSEnabledRequestWithBody generates requests for SetDDoSEnabled with any type of body
func NewSetDDoSEnabledRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/ddos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddDDoSIPRequest generates requests for AddDDoSIP
func NewAddDDoSIPRequest(server string, params *AddDDoSIPParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/ddos/ips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ip", runtime.ParamLocationQuery, params.Ip); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetFirewallRequest generates requests for ResetFirewall
func NewResetFirewallRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/firewall")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFirewallStatusRequest generates requests for GetFirewallStatus
func NewGetFirewallStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/firewall")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetFirewallEnabledRequest calls the generic SetFirewallEnabled builder with application/json body
func NewSetFirewallEnabledRequest(server string, body SetFirewallEnabledJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetFirewallEnabledRequestWithBody(server, "application/json", bodyReader)
}

// NewSetFirewallEnabledRequestWithBody generates requests for SetFirewallEnabled with any type of body
func NewSetFirewallEnabledRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/firewall")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetICMPFirewallRequest generates requests for ResetICMPFirewall
func NewResetICMPFirewallRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/firewall/icmp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetICMPFirewallStatusRequest generates requests for GetICMPFirewallStatus
func NewGetICMPFirewallStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/firewall/icmp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetICMPFirewallEnabledRequest calls the generic SetICMPFirewallEnabled builder with application/json body
func NewSetICMPFirewallEnabledRequest(server string, body SetICMPFirewallEnabledJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetICMPFirewallEnabledRequestWithBody(server, "application/json", bodyReader)
}

// NewSetICMPFirewallEnabledRequestWithBody generates requests for SetICMPFirewallEnabled with any type of body
func NewSetICMPFirewallEnabledRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/firewall/icmp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddICMPFirewallRuleRequest calls the generic AddICMPFirewallRule builder with application/json body
func NewAddICMPFirewallRuleRequest(server string, body AddICMPFirewallRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddICMPFirewallRuleRequestWithBody(server, "application/json", bodyReader)
}

// NewAddICMPFirewallRuleRequestWithBody generates requests for AddICMPFirewallRule with any type of body
func NewAddICMPFirewallRuleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/firewall/icmp/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveICMPFirewallRuleRequest generates requests for RemoveICMPFirewallRule
func NewRemoveICMPFirewallRuleRequest(server string, ruleId uint8) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/firewall/icmp/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetTCPFirewallRequest generates requests for ResetTCPFirewall
func NewResetTCPFirewallRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/firewall/tcp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTCPFirewallStatusRequest generates requests for GetTCPFirewallStatus
func NewGetTCPFirewallStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/firewall/tcp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetTCPFirewallEnabledRequest calls the generic SetTCPFirewallEnabled builder with application/json body
func NewSetTCPFirewallEnabledRequest(server string, body SetTCPFirewallEnabledJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetTCPFirewallEnabledRequestWithBody(server, "application/json", bodyReader)
}

// NewSetTCPFirewallEnabledRequestWithBody generates requests for SetTCPFirewallEnabled with any type of body
func NewSetTCPFirewallEnabledRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/firewall/tcp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddTCPFirewallRuleRequest calls the generic AddTCPFirewallRule builder with application/json body
func NewAddTCPFirewallRuleRequest(server string, body AddTCPFirewallRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddTCPFirewallRuleRequestWithBody(server, "application/json", bodyReader)
}

// NewAddTCPFirewallRuleRequestWithBody generates requests for AddTCPFirewallRule with any type of body
func NewAddTCPFirewallRuleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/firewall/tcp/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveTCPFirewallRuleRequest generates requests for RemoveTCPFirewallRule
func NewRemoveTCPFirewallRuleRequest(server string, ruleId uint8) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/firewall/tcp/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetUDPFirewallRequest generates requests for ResetUDPFirewall
func NewResetUDPFirewallRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/firewall/udp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUDPFirewallStatusRequest generates requests for GetUDPFirewallStatus
func NewGetUDPFirewallStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/firewall/udp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetUDPFirewallEnabledRequest calls the generic SetUDPFirewallEnabled builder with application/json body
func NewSetUDPFirewallEnabledRequest(server string, body SetUDPFirewallEnabledJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetUDPFirewallEnabledRequestWithBody(server, "application/json", bodyReader)
}

// NewSetUDPFirewallEnabledRequestWithBody generates requests for SetUDPFirewallEnabled with any type of body
func NewSetUDPFirewallEnabledRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/firewall/udp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddUDPFirewallRuleRequest calls the generic AddUDPFirewallRule builder with application/json body
func NewAddUDPFirewallRuleRequest(server string, body AddUDPFirewallRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUDPFirewallRuleRequestWithBody(server, "application/json", bodyReader)
}

// NewAddUDPFirewallRuleRequestWithBody generates requests for AddUDPFirewallRule with any type of body
func NewAddUDPFirewallRuleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/firewall/udp/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveUDPFirewallRuleRequest generates requests for RemoveUDPFirewallRule
func NewRemoveUDPFirewallRuleRequest(server string, ruleId uint8) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/firewall/udp/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteIPRequest generates requests for DeleteIP
func NewDeleteIPRequest(server string, params *DeleteIPParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/ips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ip", runtime.ParamLocationQuery, params.Ip); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIPsRequest generates requests for ListIPs
func NewListIPsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/ips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIPRequest generates requests for CreateIP
func NewCreateIPRequest(server string, params *CreateIPParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/ips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ip", runtime.ParamLocationQuery, params.Ip); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRouterInterfacesRequest calls the generic SetRouterInterfaces builder with application/json body
func NewSetRouterInterfacesRequest(server string, body SetRouterInterfacesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetRouterInterfacesRequestWithBody(server, "application/json", bodyReader)
}

// NewSetRouterInterfacesRequestWithBody generates requests for SetRouterInterfaces with any type of body
func NewSetRouterInterfacesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/router/interfaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetInboundNATRequest calls the generic SetInboundNAT builder with application/json body
func NewSetInboundNATRequest(server string, body SetInboundNATJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetInboundNATRequestWithBody(server, "application/json", bodyReader)
}

// NewSetInboundNATRequestWithBody generates requests for SetInboundNAT with any type of body
func NewSetInboundNATRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/router/nat/inbound")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetOutboundNATRequest calls the generic SetOutboundNAT builder with application/json body
func NewSetOutboundNATRequest(server string, body SetOutboundNATJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetOutboundNATRequestWithBody(server, "application/json", bodyReader)
}

// NewSetOutboundNATRequestWithBody generates requests for SetOutboundNAT with any type of body
func NewSetOutboundNATRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/router/nat/outbound")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRouterStatusRequest generates requests for GetRouterStatus
func NewGetRouterStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/router/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStateRequest generates requests for GetState
func NewGetStateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/state")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetStateRequest calls the generic SetState builder with application/json body
func NewSetStateRequest(server string, body SetStateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetStateRequestWithBody(server, "application/json", bodyReader)
}

// NewSetStateRequestWithBody generates requests for SetState with any type of body
func NewSetStateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transit/state")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ResetDDoSWithResponse request
	ResetDDoSWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResetDDoSResponse, error)

	// GetDDoSStatusWithResponse request
	GetDDoSStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDDoSStatusResponse, error)

	// SetDDoSEnabledWithBodyWithResponse request with any body
	SetDDoSEnabledWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDDoSEnabledResponse, error)

	SetDDoSEnabledWithResponse(ctx context.Context, body SetDDoSEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDDoSEnabledResponse, error)

	// AddDDoSIPWithResponse request
	AddDDoSIPWithResponse(ctx context.Context, params *AddDDoSIPParams, reqEditors ...RequestEditorFn) (*AddDDoSIPResponse, error)

	// ResetFirewallWithResponse request
	ResetFirewallWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResetFirewallResponse, error)

	// GetFirewallStatusWithResponse request
	GetFirewallStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFirewallStatusResponse, error)

	// SetFirewallEnabledWithBodyWithResponse request with any body
	SetFirewallEnabledWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetFirewallEnabledResponse, error)

	SetFirewallEnabledWithResponse(ctx context.Context, body SetFirewallEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetFirewallEnabledResponse, error)

	// ResetICMPFirewallWithResponse request
	ResetICMPFirewallWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResetICMPFirewallResponse, error)

	// GetICMPFirewallStatusWithResponse request
	GetICMPFirewallStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetICMPFirewallStatusResponse, error)

	// SetICMPFirewallEnabledWithBodyWithResponse request with any body
	SetICMPFirewallEnabledWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetICMPFirewallEnabledResponse, error)

	SetICMPFirewallEnabledWithResponse(ctx context.Context, body SetICMPFirewallEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetICMPFirewallEnabledResponse, error)

	// AddICMPFirewallRuleWithBodyWithResponse request with any body
	AddICMPFirewallRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddICMPFirewallRuleResponse, error)

	AddICMPFirewallRuleWithResponse(ctx context.Context, body AddICMPFirewallRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddICMPFirewallRuleResponse, error)

	// RemoveICMPFirewallRuleWithResponse request
	RemoveICMPFirewallRuleWithResponse(ctx context.Context, ruleId uint8, reqEditors ...RequestEditorFn) (*RemoveICMPFirewallRuleResponse, error)

	// ResetTCPFirewallWithResponse request
	ResetTCPFirewallWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResetTCPFirewallResponse, error)

	// GetTCPFirewallStatusWithResponse request
	GetTCPFirewallStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTCPFirewallStatusResponse, error)

	// SetTCPFirewallEnabledWithBodyWithResponse request with any body
	SetTCPFirewallEnabledWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetTCPFirewallEnabledResponse, error)

	SetTCPFirewallEnabledWithResponse(ctx context.Context, body SetTCPFirewallEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetTCPFirewallEnabledResponse, error)

	// AddTCPFirewallRuleWithBodyWithResponse request with any body
	AddTCPFirewallRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTCPFirewallRuleResponse, error)

	AddTCPFirewallRuleWithResponse(ctx context.Context, body AddTCPFirewallRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTCPFirewallRuleResponse, error)

	// RemoveTCPFirewallRuleWithResponse request
	RemoveTCPFirewallRuleWithResponse(ctx context.Context, ruleId uint8, reqEditors ...RequestEditorFn) (*RemoveTCPFirewallRuleResponse, error)

	// ResetUDPFirewallWithResponse request
	ResetUDPFirewallWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResetUDPFirewallResponse, error)

	// GetUDPFirewallStatusWithResponse request
	GetUDPFirewallStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUDPFirewallStatusResponse, error)

	// SetUDPFirewallEnabledWithBodyWithResponse request with any body
	SetUDPFirewallEnabledWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetUDPFirewallEnabledResponse, error)

	SetUDPFirewallEnabledWithResponse(ctx context.Context, body SetUDPFirewallEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetUDPFirewallEnabledResponse, error)

	// AddUDPFirewallRuleWithBodyWithResponse request with any body
	AddUDPFirewallRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUDPFirewallRuleResponse, error)

	AddUDPFirewallRuleWithResponse(ctx context.Context, body AddUDPFirewallRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUDPFirewallRuleResponse, error)

	// RemoveUDPFirewallRuleWithResponse request
	RemoveUDPFirewallRuleWithResponse(ctx context.Context, ruleId uint8, reqEditors ...RequestEditorFn) (*RemoveUDPFirewallRuleResponse, error)

	// DeleteIPWithResponse request
	DeleteIPWithResponse(ctx context.Context, params *DeleteIPParams, reqEditors ...RequestEditorFn) (*DeleteIPResponse, error)

	// ListIPsWithResponse request
	ListIPsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIPsResponse, error)

	// CreateIPWithResponse request
	CreateIPWithResponse(ctx context.Context, params *CreateIPParams, reqEditors ...RequestEditorFn) (*CreateIPResponse, error)

	// SetRouterInterfacesWithBodyWithResponse request with any body
	SetRouterInterfacesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRouterInterfacesResponse, error)

	SetRouterInterfacesWithResponse(ctx context.Context, body SetRouterInterfacesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRouterInterfacesResponse, error)

	// SetInboundNATWithBodyWithResponse request with any body
	SetInboundNATWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetInboundNATResponse, error)

	SetInboundNATWithResponse(ctx context.Context, body SetInboundNATJSONRequestBody, reqEditors ...RequestEditorFn) (*SetInboundNATResponse, error)

	// SetOutboundNATWithBodyWithResponse request with any body
	SetOutboundNATWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetOutboundNATResponse, error)

	SetOutboundNATWithResponse(ctx context.Context, body SetOutboundNATJSONRequestBody, reqEditors ...RequestEditorFn) (*SetOutboundNATResponse, error)

	// GetRouterStatusWithResponse request
	GetRouterStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRouterStatusResponse, error)

	// GetStateWithResponse request
	GetStateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStateResponse, error)

	// SetStateWithBodyWithResponse request with any body
	SetStateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetStateResponse, error)

	SetStateWithResponse(ctx context.Context, body SetStateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetStateResponse, error)
}

type ResetDDoSResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DDoSStatus
}

// Status returns HTTPResponse.Status
func (r ResetDDoSResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetDDoSResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDDoSStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DDoSStatus
}

// Status returns HTTPResponse.Status
func (r GetDDoSStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDDoSStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDDoSEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DDoSStatus
}

// Status returns HTTPResponse.Status
func (r SetDDoSEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDDoSEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddDDoSIPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DDoSStatus
}

// Status returns HTTPResponse.Status
func (r AddDDoSIPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddDDoSIPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetFirewallResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FirewallStatus
}

// Status returns HTTPResponse.Status
func (r ResetFirewallResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetFirewallResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFirewallStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FirewallStatus
}

// Status returns HTTPResponse.Status
func (r GetFirewallStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFirewallStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetFirewallEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FirewallStatus
}

// Status returns HTTPResponse.Status
func (r SetFirewallEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetFirewallEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetICMPFirewallResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ICMPFirewallStatus
}

// Status returns HTTPResponse.Status
func (r ResetICMPFirewallResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetICMPFirewallResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetICMPFirewallStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ICMPFirewallStatus
}

// Status returns HTTPResponse.Status
func (r GetICMPFirewallStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetICMPFirewallStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetICMPFirewallEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ICMPFirewallStatus
}

// Status returns HTTPResponse.Status
func (r SetICMPFirewallEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetICMPFirewallEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddICMPFirewallRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ICMPFirewallRuleResponse
}

// Status returns HTTPResponse.Status
func (r AddICMPFirewallRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddICMPFirewallRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveICMPFirewallRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ICMPFirewallStatus
}

// Status returns HTTPResponse.Status
func (r RemoveICMPFirewallRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveICMPFirewallRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetTCPFirewallResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TCPFirewallStatus
}

// Status returns HTTPResponse.Status
func (r ResetTCPFirewallResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetTCPFirewallResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTCPFirewallStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TCPFirewallStatus
}

// Status returns HTTPResponse.Status
func (r GetTCPFirewallStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTCPFirewallStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetTCPFirewallEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TCPFirewallStatus
}

// Status returns HTTPResponse.Status
func (r SetTCPFirewallEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetTCPFirewallEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddTCPFirewallRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TCPFirewallRuleResponse
}

// Status returns HTTPResponse.Status
func (r AddTCPFirewallRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddTCPFirewallRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveTCPFirewallRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TCPFirewallStatus
}

// Status returns HTTPResponse.Status
func (r RemoveTCPFirewallRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveTCPFirewallRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetUDPFirewallResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UDPFirewallStatus
}

// Status returns HTTPResponse.Status
func (r ResetUDPFirewallResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetUDPFirewallResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUDPFirewallStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UDPFirewallStatus
}

// Status returns HTTPResponse.Status
func (r GetUDPFirewallStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUDPFirewallStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetUDPFirewallEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UDPFirewallStatus
}

// Status returns HTTPResponse.Status
func (r SetUDPFirewallEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetUDPFirewallEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUDPFirewallRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *UDPFirewallRuleResponse
}

// Status returns HTTPResponse.Status
func (r AddUDPFirewallRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUDPFirewallRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUDPFirewallRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UDPFirewallStatus
}

// Status returns HTTPResponse.Status
func (r RemoveUDPFirewallRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUDPFirewallRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r DeleteIPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIPsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListIPsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIPsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]string
}

// Status returns HTTPResponse.Status
func (r CreateIPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRouterInterfacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Enabled Current state of router interfaces
		Enabled *bool `json:"enabled,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetRouterInterfacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRouterInterfacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetInboundNATResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Enabled Current state of inbound NAT
		Enabled *bool `json:"enabled,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetInboundNATResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetInboundNATResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetOutboundNATResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Enabled Current state of outbound NAT
		Enabled *bool `json:"enabled,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetOutboundNATResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetOutboundNATResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRouterStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RouterStatus
}

// Status returns HTTPResponse.Status
func (r GetRouterStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRouterStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NATState
}

// Status returns HTTPResponse.Status
func (r GetStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ResetDDoSWithResponse request returning *ResetDDoSResponse
func (c *ClientWithResponses) ResetDDoSWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResetDDoSResponse, error) {
	rsp, err := c.ResetDDoS(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetDDoSResponse(rsp)
}

// GetDDoSStatusWithResponse request returning *GetDDoSStatusResponse
func (c *ClientWithResponses) GetDDoSStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDDoSStatusResponse, error) {
	rsp, err := c.GetDDoSStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDDoSStatusResponse(rsp)
}

// SetDDoSEnabledWithBodyWithResponse request with arbitrary body returning *SetDDoSEnabledResponse
func (c *ClientWithResponses) SetDDoSEnabledWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDDoSEnabledResponse, error) {
	rsp, err := c.SetDDoSEnabledWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDDoSEnabledResponse(rsp)
}

func (c *ClientWithResponses) SetDDoSEnabledWithResponse(ctx context.Context, body SetDDoSEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDDoSEnabledResponse, error) {
	rsp, err := c.SetDDoSEnabled(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDDoSEnabledResponse(rsp)
}

// AddDDoSIPWithResponse request returning *AddDDoSIPResponse
func (c *ClientWithResponses) AddDDoSIPWithResponse(ctx context.Context, params *AddDDoSIPParams, reqEditors ...RequestEditorFn) (*AddDDoSIPResponse, error) {
	rsp, err := c.AddDDoSIP(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDDoSIPResponse(rsp)
}

// ResetFirewallWithResponse request returning *ResetFirewallResponse
func (c *ClientWithResponses) ResetFirewallWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResetFirewallResponse, error) {
	rsp, err := c.ResetFirewall(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetFirewallResponse(rsp)
}

// GetFirewallStatusWithResponse request returning *GetFirewallStatusResponse
func (c *ClientWithResponses) GetFirewallStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFirewallStatusResponse, error) {
	rsp, err := c.GetFirewallStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFirewallStatusResponse(rsp)
}

// SetFirewallEnabledWithBodyWithResponse request with arbitrary body returning *SetFirewallEnabledResponse
func (c *ClientWithResponses) SetFirewallEnabledWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetFirewallEnabledResponse, error) {
	rsp, err := c.SetFirewallEnabledWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetFirewallEnabledResponse(rsp)
}

func (c *ClientWithResponses) SetFirewallEnabledWithResponse(ctx context.Context, body SetFirewallEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetFirewallEnabledResponse, error) {
	rsp, err := c.SetFirewallEnabled(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetFirewallEnabledResponse(rsp)
}

// ResetICMPFirewallWithResponse request returning *ResetICMPFirewallResponse
func (c *ClientWithResponses) ResetICMPFirewallWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResetICMPFirewallResponse, error) {
	rsp, err := c.ResetICMPFirewall(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetICMPFirewallResponse(rsp)
}

// GetICMPFirewallStatusWithResponse request returning *GetICMPFirewallStatusResponse
func (c *ClientWithResponses) GetICMPFirewallStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetICMPFirewallStatusResponse, error) {
	rsp, err := c.GetICMPFirewallStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetICMPFirewallStatusResponse(rsp)
}

// SetICMPFirewallEnabledWithBodyWithResponse request with arbitrary body returning *SetICMPFirewallEnabledResponse
func (c *ClientWithResponses) SetICMPFirewallEnabledWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetICMPFirewallEnabledResponse, error) {
	rsp, err := c.SetICMPFirewallEnabledWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetICMPFirewallEnabledResponse(rsp)
}

func (c *ClientWithResponses) SetICMPFirewallEnabledWithResponse(ctx context.Context, body SetICMPFirewallEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetICMPFirewallEnabledResponse, error) {
	rsp, err := c.SetICMPFirewallEnabled(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetICMPFirewallEnabledResponse(rsp)
}

// AddICMPFirewallRuleWithBodyWithResponse request with arbitrary body returning *AddICMPFirewallRuleResponse
func (c *ClientWithResponses) AddICMPFirewallRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddICMPFirewallRuleResponse, error) {
	rsp, err := c.AddICMPFirewallRuleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddICMPFirewallRuleResponse(rsp)
}

func (c *ClientWithResponses) AddICMPFirewallRuleWithResponse(ctx context.Context, body AddICMPFirewallRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddICMPFirewallRuleResponse, error) {
	rsp, err := c.AddICMPFirewallRule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddICMPFirewallRuleResponse(rsp)
}

// RemoveICMPFirewallRuleWithResponse request returning *RemoveICMPFirewallRuleResponse
func (c *ClientWithResponses) RemoveICMPFirewallRuleWithResponse(ctx context.Context, ruleId uint8, reqEditors ...RequestEditorFn) (*RemoveICMPFirewallRuleResponse, error) {
	rsp, err := c.RemoveICMPFirewallRule(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveICMPFirewallRuleResponse(rsp)
}

// ResetTCPFirewallWithResponse request returning *ResetTCPFirewallResponse
func (c *ClientWithResponses) ResetTCPFirewallWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResetTCPFirewallResponse, error) {
	rsp, err := c.ResetTCPFirewall(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetTCPFirewallResponse(rsp)
}

// GetTCPFirewallStatusWithResponse request returning *GetTCPFirewallStatusResponse
func (c *ClientWithResponses) GetTCPFirewallStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTCPFirewallStatusResponse, error) {
	rsp, err := c.GetTCPFirewallStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTCPFirewallStatusResponse(rsp)
}

// SetTCPFirewallEnabledWithBodyWithResponse request with arbitrary body returning *SetTCPFirewallEnabledResponse
func (c *ClientWithResponses) SetTCPFirewallEnabledWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetTCPFirewallEnabledResponse, error) {
	rsp, err := c.SetTCPFirewallEnabledWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetTCPFirewallEnabledResponse(rsp)
}

func (c *ClientWithResponses) SetTCPFirewallEnabledWithResponse(ctx context.Context, body SetTCPFirewallEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetTCPFirewallEnabledResponse, error) {
	rsp, err := c.SetTCPFirewallEnabled(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetTCPFirewallEnabledResponse(rsp)
}

// AddTCPFirewallRuleWithBodyWithResponse request with arbitrary body returning *AddTCPFirewallRuleResponse
func (c *ClientWithResponses) AddTCPFirewallRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTCPFirewallRuleResponse, error) {
	rsp, err := c.AddTCPFirewallRuleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTCPFirewallRuleResponse(rsp)
}

func (c *ClientWithResponses) AddTCPFirewallRuleWithResponse(ctx context.Context, body AddTCPFirewallRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTCPFirewallRuleResponse, error) {
	rsp, err := c.AddTCPFirewallRule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTCPFirewallRuleResponse(rsp)
}

// RemoveTCPFirewallRuleWithResponse request returning *RemoveTCPFirewallRuleResponse
func (c *ClientWithResponses) RemoveTCPFirewallRuleWithResponse(ctx context.Context, ruleId uint8, reqEditors ...RequestEditorFn) (*RemoveTCPFirewallRuleResponse, error) {
	rsp, err := c.RemoveTCPFirewallRule(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTCPFirewallRuleResponse(rsp)
}

// ResetUDPFirewallWithResponse request returning *ResetUDPFirewallResponse
func (c *ClientWithResponses) ResetUDPFirewallWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResetUDPFirewallResponse, error) {
	rsp, err := c.ResetUDPFirewall(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetUDPFirewallResponse(rsp)
}

// GetUDPFirewallStatusWithResponse request returning *GetUDPFirewallStatusResponse
func (c *ClientWithResponses) GetUDPFirewallStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUDPFirewallStatusResponse, error) {
	rsp, err := c.GetUDPFirewallStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUDPFirewallStatusResponse(rsp)
}

// SetUDPFirewallEnabledWithBodyWithResponse request with arbitrary body returning *SetUDPFirewallEnabledResponse
func (c *ClientWithResponses) SetUDPFirewallEnabledWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetUDPFirewallEnabledResponse, error) {
	rsp, err := c.SetUDPFirewallEnabledWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetUDPFirewallEnabledResponse(rsp)
}

func (c *ClientWithResponses) SetUDPFirewallEnabledWithResponse(ctx context.Context, body SetUDPFirewallEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetUDPFirewallEnabledResponse, error) {
	rsp, err := c.SetUDPFirewallEnabled(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetUDPFirewallEnabledResponse(rsp)
}

// AddUDPFirewallRuleWithBodyWithResponse request with arbitrary body returning *AddUDPFirewallRuleResponse
func (c *ClientWithResponses) AddUDPFirewallRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUDPFirewallRuleResponse, error) {
	rsp, err := c.AddUDPFirewallRuleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUDPFirewallRuleResponse(rsp)
}

func (c *ClientWithResponses) AddUDPFirewallRuleWithResponse(ctx context.Context, body AddUDPFirewallRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUDPFirewallRuleResponse, error) {
	rsp, err := c.AddUDPFirewallRule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUDPFirewallRuleResponse(rsp)
}

// RemoveUDPFirewallRuleWithResponse request returning *RemoveUDPFirewallRuleResponse
func (c *ClientWithResponses) RemoveUDPFirewallRuleWithResponse(ctx context.Context, ruleId uint8, reqEditors ...RequestEditorFn) (*RemoveUDPFirewallRuleResponse, error) {
	rsp, err := c.RemoveUDPFirewallRule(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUDPFirewallRuleResponse(rsp)
}

// DeleteIPWithResponse request returning *DeleteIPResponse
func (c *ClientWithResponses) DeleteIPWithResponse(ctx context.Context, params *DeleteIPParams, reqEditors ...RequestEditorFn) (*DeleteIPResponse, error) {
	rsp, err := c.DeleteIP(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIPResponse(rsp)
}

// ListIPsWithResponse request returning *ListIPsResponse
func (c *ClientWithResponses) ListIPsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIPsResponse, error) {
	rsp, err := c.ListIPs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIPsResponse(rsp)
}

// CreateIPWithResponse request returning *CreateIPResponse
func (c *ClientWithResponses) CreateIPWithResponse(ctx context.Context, params *CreateIPParams, reqEditors ...RequestEditorFn) (*CreateIPResponse, error) {
	rsp, err := c.CreateIP(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIPResponse(rsp)
}

// SetRouterInterfacesWithBodyWithResponse request with arbitrary body returning *SetRouterInterfacesResponse
func (c *ClientWithResponses) SetRouterInterfacesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRouterInterfacesResponse, error) {
	rsp, err := c.SetRouterInterfacesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRouterInterfacesResponse(rsp)
}

func (c *ClientWithResponses) SetRouterInterfacesWithResponse(ctx context.Context, body SetRouterInterfacesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRouterInterfacesResponse, error) {
	rsp, err := c.SetRouterInterfaces(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRouterInterfacesResponse(rsp)
}

// SetInboundNATWithBodyWithResponse request with arbitrary body returning *SetInboundNATResponse
func (c *ClientWithResponses) SetInboundNATWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetInboundNATResponse, error) {
	rsp, err := c.SetInboundNATWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetInboundNATResponse(rsp)
}

func (c *ClientWithResponses) SetInboundNATWithResponse(ctx context.Context, body SetInboundNATJSONRequestBody, reqEditors ...RequestEditorFn) (*SetInboundNATResponse, error) {
	rsp, err := c.SetInboundNAT(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetInboundNATResponse(rsp)
}

// SetOutboundNATWithBodyWithResponse request with arbitrary body returning *SetOutboundNATResponse
func (c *ClientWithResponses) SetOutboundNATWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetOutboundNATResponse, error) {
	rsp, err := c.SetOutboundNATWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetOutboundNATResponse(rsp)
}

func (c *ClientWithResponses) SetOutboundNATWithResponse(ctx context.Context, body SetOutboundNATJSONRequestBody, reqEditors ...RequestEditorFn) (*SetOutboundNATResponse, error) {
	rsp, err := c.SetOutboundNAT(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetOutboundNATResponse(rsp)
}

// GetRouterStatusWithResponse request returning *GetRouterStatusResponse
func (c *ClientWithResponses) GetRouterStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRouterStatusResponse, error) {
	rsp, err := c.GetRouterStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRouterStatusResponse(rsp)
}

// GetStateWithResponse request returning *GetStateResponse
func (c *ClientWithResponses) GetStateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStateResponse, error) {
	rsp, err := c.GetState(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStateResponse(rsp)
}

// SetStateWithBodyWithResponse request with arbitrary body returning *SetStateResponse
func (c *ClientWithResponses) SetStateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetStateResponse, error) {
	rsp, err := c.SetStateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetStateResponse(rsp)
}

func (c *ClientWithResponses) SetStateWithResponse(ctx context.Context, body SetStateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetStateResponse, error) {
	rsp, err := c.SetState(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetStateResponse(rsp)
}

// ParseResetDDoSResponse parses an HTTP response from a ResetDDoSWithResponse call
func ParseResetDDoSResponse(rsp *http.Response) (*ResetDDoSResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetDDoSResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DDoSStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDDoSStatusResponse parses an HTTP response from a GetDDoSStatusWithResponse call
func ParseGetDDoSStatusResponse(rsp *http.Response) (*GetDDoSStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDDoSStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DDoSStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetDDoSEnabledResponse parses an HTTP response from a SetDDoSEnabledWithResponse call
func ParseSetDDoSEnabledResponse(rsp *http.Response) (*SetDDoSEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDDoSEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DDoSStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddDDoSIPResponse parses an HTTP response from a AddDDoSIPWithResponse call
func ParseAddDDoSIPResponse(rsp *http.Response) (*AddDDoSIPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddDDoSIPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DDoSStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseResetFirewallResponse parses an HTTP response from a ResetFirewallWithResponse call
func ParseResetFirewallResponse(rsp *http.Response) (*ResetFirewallResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetFirewallResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FirewallStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFirewallStatusResponse parses an HTTP response from a GetFirewallStatusWithResponse call
func ParseGetFirewallStatusResponse(rsp *http.Response) (*GetFirewallStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFirewallStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FirewallStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetFirewallEnabledResponse parses an HTTP response from a SetFirewallEnabledWithResponse call
func ParseSetFirewallEnabledResponse(rsp *http.Response) (*SetFirewallEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetFirewallEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FirewallStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResetICMPFirewallResponse parses an HTTP response from a ResetICMPFirewallWithResponse call
func ParseResetICMPFirewallResponse(rsp *http.Response) (*ResetICMPFirewallResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetICMPFirewallResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ICMPFirewallStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetICMPFirewallStatusResponse parses an HTTP response from a GetICMPFirewallStatusWithResponse call
func ParseGetICMPFirewallStatusResponse(rsp *http.Response) (*GetICMPFirewallStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetICMPFirewallStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ICMPFirewallStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetICMPFirewallEnabledResponse parses an HTTP response from a SetICMPFirewallEnabledWithResponse call
func ParseSetICMPFirewallEnabledResponse(rsp *http.Response) (*SetICMPFirewallEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetICMPFirewallEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ICMPFirewallStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddICMPFirewallRuleResponse parses an HTTP response from a AddICMPFirewallRuleWithResponse call
func ParseAddICMPFirewallRuleResponse(rsp *http.Response) (*AddICMPFirewallRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddICMPFirewallRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ICMPFirewallRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseRemoveICMPFirewallRuleResponse parses an HTTP response from a RemoveICMPFirewallRuleWithResponse call
func ParseRemoveICMPFirewallRuleResponse(rsp *http.Response) (*RemoveICMPFirewallRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveICMPFirewallRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ICMPFirewallStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResetTCPFirewallResponse parses an HTTP response from a ResetTCPFirewallWithResponse call
func ParseResetTCPFirewallResponse(rsp *http.Response) (*ResetTCPFirewallResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetTCPFirewallResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TCPFirewallStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTCPFirewallStatusResponse parses an HTTP response from a GetTCPFirewallStatusWithResponse call
func ParseGetTCPFirewallStatusResponse(rsp *http.Response) (*GetTCPFirewallStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTCPFirewallStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TCPFirewallStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetTCPFirewallEnabledResponse parses an HTTP response from a SetTCPFirewallEnabledWithResponse call
func ParseSetTCPFirewallEnabledResponse(rsp *http.Response) (*SetTCPFirewallEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetTCPFirewallEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TCPFirewallStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddTCPFirewallRuleResponse parses an HTTP response from a AddTCPFirewallRuleWithResponse call
func ParseAddTCPFirewallRuleResponse(rsp *http.Response) (*AddTCPFirewallRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddTCPFirewallRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TCPFirewallRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseRemoveTCPFirewallRuleResponse parses an HTTP response from a RemoveTCPFirewallRuleWithResponse call
func ParseRemoveTCPFirewallRuleResponse(rsp *http.Response) (*RemoveTCPFirewallRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveTCPFirewallRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TCPFirewallStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResetUDPFirewallResponse parses an HTTP response from a ResetUDPFirewallWithResponse call
func ParseResetUDPFirewallResponse(rsp *http.Response) (*ResetUDPFirewallResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetUDPFirewallResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UDPFirewallStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUDPFirewallStatusResponse parses an HTTP response from a GetUDPFirewallStatusWithResponse call
func ParseGetUDPFirewallStatusResponse(rsp *http.Response) (*GetUDPFirewallStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUDPFirewallStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UDPFirewallStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetUDPFirewallEnabledResponse parses an HTTP response from a SetUDPFirewallEnabledWithResponse call
func ParseSetUDPFirewallEnabledResponse(rsp *http.Response) (*SetUDPFirewallEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetUDPFirewallEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UDPFirewallStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddUDPFirewallRuleResponse parses an HTTP response from a AddUDPFirewallRuleWithResponse call
func ParseAddUDPFirewallRuleResponse(rsp *http.Response) (*AddUDPFirewallRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUDPFirewallRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest UDPFirewallRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseRemoveUDPFirewallRuleResponse parses an HTTP response from a RemoveUDPFirewallRuleWithResponse call
func ParseRemoveUDPFirewallRuleResponse(rsp *http.Response) (*RemoveUDPFirewallRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUDPFirewallRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UDPFirewallStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteIPResponse parses an HTTP response from a DeleteIPWithResponse call
func ParseDeleteIPResponse(rsp *http.Response) (*DeleteIPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListIPsResponse parses an HTTP response from a ListIPsWithResponse call
func ParseListIPsResponse(rsp *http.Response) (*ListIPsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIPsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateIPResponse parses an HTTP response from a CreateIPWithResponse call
func ParseCreateIPResponse(rsp *http.Response) (*CreateIPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseSetRouterInterfacesResponse parses an HTTP response from a SetRouterInterfacesWithResponse call
func ParseSetRouterInterfacesResponse(rsp *http.Response) (*SetRouterInterfacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetRouterInterfacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Enabled Current state of router interfaces
			Enabled *bool `json:"enabled,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetInboundNATResponse parses an HTTP response from a SetInboundNATWithResponse call
func ParseSetInboundNATResponse(rsp *http.Response) (*SetInboundNATResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetInboundNATResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Enabled Current state of inbound NAT
			Enabled *bool `json:"enabled,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetOutboundNATResponse parses an HTTP response from a SetOutboundNATWithResponse call
func ParseSetOutboundNATResponse(rsp *http.Response) (*SetOutboundNATResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetOutboundNATResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Enabled Current state of outbound NAT
			Enabled *bool `json:"enabled,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRouterStatusResponse parses an HTTP response from a GetRouterStatusWithResponse call
func ParseGetRouterStatusResponse(rsp *http.Response) (*GetRouterStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRouterStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RouterStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStateResponse parses an HTTP response from a GetStateWithResponse call
func ParseGetStateResponse(rsp *http.Response) (*GetStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NATState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetStateResponse parses an HTTP response from a SetStateWithResponse call
func ParseSetStateResponse(rsp *http.Response) (*SetStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
