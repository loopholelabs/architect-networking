// Code generated by fRPC Go v0.10.0, DO NOT EDIT.
// source: failover.proto

package failover

import (
	"context
	"errors"

	"git
	"net"
	"github.com/loopholelabs/polyglot/v2"

	"crypto/tls"
	"github.com/loopholelabs/frisbee-go"
	"github.com/loopholelabs/frisbee-go/pkg/packet"
	"github.com/loopholelabs/logging/types"
)

var (
	ErrDecodeNil = errors.New("cannot decode into a nil root struct")
)

type FailoverSyncStateRequest struct {
	error error
	flags uint8

	RequestId string
}

func NewFailoverSyncStateRequest() *FailoverSyncStateRequest {
	return &FailoverSyncStateRequest{}
}

func (x *FailoverSyncStateRequest) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *FailoverSyncStateRequest) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.RequestId)
	}
}

func (x *FailoverSyncStateRequest) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *FailoverSyncStateRequest) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.RequestId, err = d.String()
	if err != nil {
		return err
	}
	return nil
}

type FailoverNATKey struct {
	error error
	flags uint8

	DestinationIp   string
	DestinationPort uint32
	SourceIp        string
	SourcePort      uint32
}

func NewFailoverNATKey() *FailoverNATKey {
	return &FailoverNATKey{}
}

func (x *FailoverNATKey) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *FailoverNATKey) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.DestinationIp).Uint32(x.DestinationPort).String(x.SourceIp).Uint32(x.SourcePort)
	}
}

func (x *FailoverNATKey) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *FailoverNATKey) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.DestinationIp, err = d.String()
	if err != nil {
		return err
	}
	x.DestinationPort, err = d.Uint32()
	if err != nil {
		return err
	}
	x.SourceIp, err = d.String()
	if err != nil {
		return err
	}
	x.SourcePort, err = d.Uint32()
	if err != nil {
		return err
	}
	return nil
}

type FailoverNATValue struct {
	error error
	flags uint8

	LastSeen      string
	TranslateIp   string
	TranslatePort uint32
}

func NewFailoverNATValue() *FailoverNATValue {
	return &FailoverNATValue{}
}

func (x *FailoverNATValue) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *FailoverNATValue) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.LastSeen).String(x.TranslateIp).Uint32(x.TranslatePort)
	}
}

func (x *FailoverNATValue) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *FailoverNATValue) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.LastSeen, err = d.String()
	if err != nil {
		return err
	}
	x.TranslateIp, err = d.String()
	if err != nil {
		return err
	}
	x.TranslatePort, err = d.Uint32()
	if err != nil {
		return err
	}
	return nil
}

type FailoverNATKeyValuePair struct {
	error error
	flags uint8

	Key   *FailoverNATKey
	Value *FailoverNATValue
}

func NewFailoverNATKeyValuePair() *FailoverNATKeyValuePair {
	return &FailoverNATKeyValuePair{}
}

func (x *FailoverNATKeyValuePair) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *FailoverNATKeyValuePair) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)

		x.Key.Encode(b)
		x.Value.Encode(b)
	}
}

func (x *FailoverNATKeyValuePair) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *FailoverNATKeyValuePair) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	if !d.Nil() {
		x.Key = NewFailoverNATKey()
		err = x.Key.decode(d)
		if err != nil {
			return err
		}
	}
	if !d.Nil() {
		x.Value = NewFailoverNATValue()
		err = x.Value.decode(d)
		if err != nil {
			return err
		}
	}
	return nil
}

type FailoverNATBitmapPair struct {
	error error
	flags uint8

	Bitmap        string
	DestinationIp string
	LastChunk     uint32
	Natip         string
}

func NewFailoverNATBitmapPair() *FailoverNATBitmapPair {
	return &FailoverNATBitmapPair{}
}

func (x *FailoverNATBitmapPair) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *FailoverNATBitmapPair) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.Bitmap).String(x.DestinationIp).Uint32(x.LastChunk).String(x.Natip)
	}
}

func (x *FailoverNATBitmapPair) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *FailoverNATBitmapPair) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Bitmap, err = d.String()
	if err != nil {
		return err
	}
	x.DestinationIp, err = d.String()
	if err != nil {
		return err
	}
	x.LastChunk, err = d.Uint32()
	if err != nil {
		return err
	}
	x.Natip, err = d.String()
	if err != nil {
		return err
	}
	return nil
}

type FailoverNATState struct {
	error error
	flags uint8

	Ips         []string
	TcpInbound  []*FailoverNATKeyValuePair
	TcpOutbound []*FailoverNATKeyValuePair
	UdpInbound  []*FailoverNATKeyValuePair
	UdpOutbound []*FailoverNATKeyValuePair
	NatPorts    []*FailoverNATBitmapPair
}

func NewFailoverNATState() *FailoverNATState {
	return &FailoverNATState{}
}

func (x *FailoverNATState) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *FailoverNATState) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)

		polyglot.Encoder(b).Slice(uint32(len(x.Ips)), polyglot.StringKind)
		for _, v := range x.Ips {
			polyglot.Encoder(b).String(v)
		}
		polyglot.Encoder(b).Slice(uint32(len(x.TcpInbound)), polyglot.AnyKind)
		for _, v := range x.TcpInbound {
			v.Encode(b)
		}
		polyglot.Encoder(b).Slice(uint32(len(x.TcpOutbound)), polyglot.AnyKind)
		for _, v := range x.TcpOutbound {
			v.Encode(b)
		}
		polyglot.Encoder(b).Slice(uint32(len(x.UdpInbound)), polyglot.AnyKind)
		for _, v := range x.UdpInbound {
			v.Encode(b)
		}
		polyglot.Encoder(b).Slice(uint32(len(x.UdpOutbound)), polyglot.AnyKind)
		for _, v := range x.UdpOutbound {
			v.Encode(b)
		}
		polyglot.Encoder(b).Slice(uint32(len(x.NatPorts)), polyglot.AnyKind)
		for _, v := range x.NatPorts {
			v.Encode(b)
		}
	}
}

func (x *FailoverNATState) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *FailoverNATState) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	var sliceSize uint32
	sliceSize, err = d.Slice(polyglot.StringKind)
	if err != nil {
		return err
	}
	if uint32(len(x.Ips)) != sliceSize {
		x.Ips = make([]string, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		x.Ips[i], err = d.String()
		if err != nil {
			return err
		}
	}
	sliceSize, err = d.Slice(polyglot.AnyKind)
	if err != nil {
		return err
	}
	if uint32(len(x.TcpInbound)) != sliceSize {
		x.TcpInbound = make([]*FailoverNATKeyValuePair, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		if x.TcpInbound[i] == nil {
			x.TcpInbound[i] = NewFailoverNATKeyValuePair()
		}
		err = x.TcpInbound[i].decode(d)
		if err != nil {
			return err
		}
	}
	sliceSize, err = d.Slice(polyglot.AnyKind)
	if err != nil {
		return err
	}
	if uint32(len(x.TcpOutbound)) != sliceSize {
		x.TcpOutbound = make([]*FailoverNATKeyValuePair, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		if x.TcpOutbound[i] == nil {
			x.TcpOutbound[i] = NewFailoverNATKeyValuePair()
		}
		err = x.TcpOutbound[i].decode(d)
		if err != nil {
			return err
		}
	}
	sliceSize, err = d.Slice(polyglot.AnyKind)
	if err != nil {
		return err
	}
	if uint32(len(x.UdpInbound)) != sliceSize {
		x.UdpInbound = make([]*FailoverNATKeyValuePair, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		if x.UdpInbound[i] == nil {
			x.UdpInbound[i] = NewFailoverNATKeyValuePair()
		}
		err = x.UdpInbound[i].decode(d)
		if err != nil {
			return err
		}
	}
	sliceSize, err = d.Slice(polyglot.AnyKind)
	if err != nil {
		return err
	}
	if uint32(len(x.UdpOutbound)) != sliceSize {
		x.UdpOutbound = make([]*FailoverNATKeyValuePair, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		if x.UdpOutbound[i] == nil {
			x.UdpOutbound[i] = NewFailoverNATKeyValuePair()
		}
		err = x.UdpOutbound[i].decode(d)
		if err != nil {
			return err
		}
	}
	sliceSize, err = d.Slice(polyglot.AnyKind)
	if err != nil {
		return err
	}
	if uint32(len(x.NatPorts)) != sliceSize {
		x.NatPorts = make([]*FailoverNATBitmapPair, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		if x.NatPorts[i] == nil {
			x.NatPorts[i] = NewFailoverNATBitmapPair()
		}
		err = x.NatPorts[i].decode(d)
		if err != nil {
			return err
		}
	}
	return nil
}

type FailoverSyncStateResponse struct {
	error error
	flags uint8

	RequestId    string
	Success      bool
	ErrorMessage string
	State        *FailoverNATState
}

func NewFailoverSyncStateResponse() *FailoverSyncStateResponse {
	return &FailoverSyncStateResponse{}
}

func (x *FailoverSyncStateResponse) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *FailoverSyncStateResponse) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.RequestId).Bool(x.Success).String(x.ErrorMessage)
		x.State.Encode(b)
	}
}

func (x *FailoverSyncStateResponse) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *FailoverSyncStateResponse) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.RequestId, err = d.String()
	if err != nil {
		return err
	}
	x.Success, err = d.Bool()
	if err != nil {
		return err
	}
	x.ErrorMessage, err = d.String()
	if err != nil {
		return err
	}
	if !d.Nil() {
		x.State = NewFailoverNATState()
		err = x.State.decode(d)
		if err != nil {
			return err
		}
	}
	return nil
}

type FailoverHealthCheckRequest struct {
	error error
	flags uint8

	RequestId string
}

func NewFailoverHealthCheckRequest() *FailoverHealthCheckRequest {
	return &FailoverHealthCheckRequest{}
}

func (x *FailoverHealthCheckRequest) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *FailoverHealthCheckRequest) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.RequestId)
	}
}

func (x *FailoverHealthCheckRequest) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *FailoverHealthCheckRequest) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.RequestId, err = d.String()
	if err != nil {
		return err
	}
	return nil
}

type FailoverHealthCheckResponse struct {
	error error
	flags uint8

	RequestId  string
	Success    bool
	NodeRole   string
	InstanceId string
}

func NewFailoverHealthCheckResponse() *FailoverHealthCheckResponse {
	return &FailoverHealthCheckResponse{}
}

func (x *FailoverHealthCheckResponse) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *FailoverHealthCheckResponse) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.RequestId).Bool(x.Success).String(x.NodeRole).String(x.InstanceId)
	}
}

func (x *FailoverHealthCheckResponse) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *FailoverHealthCheckResponse) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.RequestId, err = d.String()
	if err != nil {
		return err
	}
	x.Success, err = d.Bool()
	if err != nil {
		return err
	}
	x.NodeRole, err = d.String()
	if err != nil {
		return err
	}
	x.InstanceId, err = d.String()
	if err != nil {
		return err
	}
	return nil
}

type FailoverHeartbeatRequest struct {
	error error
	flags uint8

	RequestId  string
	Timestamp  int64
	PrimaryEni string
}

func NewFailoverHeartbeatRequest() *FailoverHeartbeatRequest {
	return &FailoverHeartbeatRequest{}
}

func (x *FailoverHeartbeatRequest) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *FailoverHeartbeatRequest) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.RequestId).Int64(x.Timestamp).String(x.PrimaryEni)
	}
}

func (x *FailoverHeartbeatRequest) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *FailoverHeartbeatRequest) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.RequestId, err = d.String()
	if err != nil {
		return err
	}
	x.Timestamp, err = d.Int64()
	if err != nil {
		return err
	}
	x.PrimaryEni, err = d.String()
	if err != nil {
		return err
	}
	return nil
}

type FailoverHeartbeatResponse struct {
	error error
	flags uint8

	RequestId string
	Success   bool
	Timestamp int64
}

func NewFailoverHeartbeatResponse() *FailoverHeartbeatResponse {
	return &FailoverHeartbeatResponse{}
}

func (x *FailoverHeartbeatResponse) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *FailoverHeartbeatResponse) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.RequestId).Bool(x.Success).Int64(x.Timestamp)
	}
}

func (x *FailoverHeartbeatResponse) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *FailoverHeartbeatResponse) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.RequestId, err = d.String()
	if err != nil {
		return err
	}
	x.Success, err = d.Bool()
	if err != nil {
		return err
	}
	x.Timestamp, err = d.Int64()
	if err != nil {
		return err
	}
	return nil
}

type FailoverService interface {
	SyncState(context.Context, *FailoverSyncStateRequest) (*FailoverSyncStateResponse, error)
	HealthCheck(context.Context, *FailoverHealthCheckRequest) (*FailoverHealthCheckResponse, error)
	Heartbeat(context.Context, *FailoverHeartbeatRequest) (*FailoverHeartbeatResponse, error)
}

const ConnectionContextKey int = 1000
const StreamContextKey int = 1001

func SetErrorFlag(flags uint8, error bool) uint8 {
	return flags | 0x2
}
func HasErrorFlag(flags uint8) bool {
	return flags&(1<<1) == 1
}

type Server struct {
	server *frisbee.Server
}

func NewServer(failoverService FailoverService, tlsConfig *tls.Config, logger types.Logger) (*Server, error) {
	s := new(Server)
	table := make(frisbee.HandlerTable)

	table[10] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewFailoverSyncStateRequest()
		err := req.Decode((*incoming.Content).Bytes()[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *FailoverSyncStateResponse
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = failoverService.SyncState(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(outgoing.Content.Len())
		}
		return
	}
	table[11] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewFailoverHealthCheckRequest()
		err := req.Decode((*incoming.Content).Bytes()[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *FailoverHealthCheckResponse
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = failoverService.HealthCheck(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(outgoing.Content.Len())
		}
		return
	}
	table[12] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewFailoverHeartbeatRequest()
		err := req.Decode((*incoming.Content).Bytes()[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *FailoverHeartbeatResponse
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = failoverService.Heartbeat(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(outgoing.Content.Len())
		}
		return
	}
	var err error
	if tlsConfig != nil {
		s.server, err = frisbee.NewServer(table, context.Background(), frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		s.server, err = frisbee.NewServer(table, context.Background(), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	s.server.ConnContext = func(ctx context.Context, conn *frisbee.Async) context.Context {
		return context.WithValue(ctx, ConnectionContextKey, conn)
	}

	return s, nil
}

func (s *Server) SetOnClosed(f func(*frisbee.Async, error)) error {
	return s.server.SetOnClosed(f)
}

func (s *Server) SetPreWrite(f func()) error {
	return s.server.SetPreWrite(f)
}

func (s *Server) SetConcurrency(concurrency uint64) {
	s.server.SetConcurrency(concurrency)
}

func (s *Server) Start(addr string) error {
	return s.server.Start(addr)
}

func (s *Server) StartWithListener(listener net.Listener) error {
	return s.server.StartWithListener(listener)
}

func (s *Server) ServeConn(conn net.Conn) {
	s.server.ServeConn(conn)
}

func (s *Server) Shutdown() error {
	err := s.server.Shutdown()
	if err != nil {
		return err
	}
	return nil
}

type subFailoverServiceClient struct {
	client                *frisbee.Client
	nextSyncState         uint16
	nextSyncStateMu       sync.RWMutex
	inflightSyncState     map[uint16]chan *FailoverSyncStateResponse
	inflightSyncStateMu   sync.RWMutex
	nextHealthCheck       uint16
	nextHealthCheckMu     sync.RWMutex
	inflightHealthCheck   map[uint16]chan *FailoverHealthCheckResponse
	inflightHealthCheckMu sync.RWMutex
	nextHeartbeat         uint16
	nextHeartbeatMu       sync.RWMutex
	inflightHeartbeat     map[uint16]chan *FailoverHeartbeatResponse
	inflightHeartbeatMu   sync.RWMutex
	nextStreamingID       uint16
	nextStreamingIDMu     sync.RWMutex
}
type Client struct {
	*frisbee.Client
	FailoverService *subFailoverServiceClient
}

func NewClient(tlsConfig *tls.Config, logger types.Logger) (*Client, error) {
	c := new(Client)
	table := make(frisbee.HandlerTable)

	table[10] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.FailoverService.inflightSyncStateMu.RLock()
		if ch, ok := c.FailoverService.inflightSyncState[incoming.Metadata.Id]; ok {
			c.FailoverService.inflightSyncStateMu.RUnlock()
			res := NewFailoverSyncStateResponse()
			res.Decode((*incoming.Content).Bytes()[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.FailoverService.inflightSyncStateMu.RUnlock()
		}
		return
	}
	table[11] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.FailoverService.inflightHealthCheckMu.RLock()
		if ch, ok := c.FailoverService.inflightHealthCheck[incoming.Metadata.Id]; ok {
			c.FailoverService.inflightHealthCheckMu.RUnlock()
			res := NewFailoverHealthCheckResponse()
			res.Decode((*incoming.Content).Bytes()[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.FailoverService.inflightHealthCheckMu.RUnlock()
		}
		return
	}
	table[12] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.FailoverService.inflightHeartbeatMu.RLock()
		if ch, ok := c.FailoverService.inflightHeartbeat[incoming.Metadata.Id]; ok {
			c.FailoverService.inflightHeartbeatMu.RUnlock()
			res := NewFailoverHeartbeatResponse()
			res.Decode((*incoming.Content).Bytes()[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.FailoverService.inflightHeartbeatMu.RUnlock()
		}
		return
	}
	var err error
	if tlsConfig != nil {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	c.FailoverService = new(subFailoverServiceClient)
	c.FailoverService.client = c.Client
	c.FailoverService.nextSyncStateMu.Lock()
	c.FailoverService.nextSyncState = 0
	c.FailoverService.nextSyncStateMu.Unlock()
	c.FailoverService.inflightSyncState = make(map[uint16]chan *FailoverSyncStateResponse)
	c.FailoverService.nextHealthCheckMu.Lock()
	c.FailoverService.nextHealthCheck = 0
	c.FailoverService.nextHealthCheckMu.Unlock()
	c.FailoverService.inflightHealthCheck = make(map[uint16]chan *FailoverHealthCheckResponse)
	c.FailoverService.nextHeartbeatMu.Lock()
	c.FailoverService.nextHeartbeat = 0
	c.FailoverService.nextHeartbeatMu.Unlock()
	c.FailoverService.inflightHeartbeat = make(map[uint16]chan *FailoverHeartbeatResponse)
	return c, nil
}

func (c *Client) Connect(addr string, streamHandler ...frisbee.NewStreamHandler) error {
	return c.Client.Connect(addr, func(stream *frisbee.Stream) {})
}

func (c *Client) FromConn(conn net.Conn, streamHandler ...frisbee.NewStreamHandler) error {
	return c.Client.FromConn(conn, func(stream *frisbee.Stream) {})
}

func (c *subFailoverServiceClient) SyncState(ctx context.Context, req *FailoverSyncStateRequest) (res *FailoverSyncStateResponse, err error) {
	ch := make(chan *FailoverSyncStateResponse, 1)
	p := packet.Get()
	p.Metadata.Operation = 10

	c.nextSyncStateMu.Lock()
	c.nextSyncState += 1
	id := c.nextSyncState
	c.nextSyncStateMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32((*p.Content).Len())
	c.inflightSyncStateMu.Lock()
	c.inflightSyncState[id] = ch
	c.inflightSyncStateMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case <-c.client.CloseChannel():
		err = c.client.Error()
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightSyncStateMu.Lock()
	delete(c.inflightSyncState, id)
	c.inflightSyncStateMu.Unlock()
	packet.Put(p)
	return
}

func (c *subFailoverServiceClient) HealthCheck(ctx context.Context, req *FailoverHealthCheckRequest) (res *FailoverHealthCheckResponse, err error) {
	ch := make(chan *FailoverHealthCheckResponse, 1)
	p := packet.Get()
	p.Metadata.Operation = 11

	c.nextHealthCheckMu.Lock()
	c.nextHealthCheck += 1
	id := c.nextHealthCheck
	c.nextHealthCheckMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32((*p.Content).Len())
	c.inflightHealthCheckMu.Lock()
	c.inflightHealthCheck[id] = ch
	c.inflightHealthCheckMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case <-c.client.CloseChannel():
		err = c.client.Error()
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightHealthCheckMu.Lock()
	delete(c.inflightHealthCheck, id)
	c.inflightHealthCheckMu.Unlock()
	packet.Put(p)
	return
}

func (c *subFailoverServiceClient) Heartbeat(ctx context.Context, req *FailoverHeartbeatRequest) (res *FailoverHeartbeatResponse, err error) {
	ch := make(chan *FailoverHeartbeatResponse, 1)
	p := packet.Get()
	p.Metadata.Operation = 12

	c.nextHeartbeatMu.Lock()
	c.nextHeartbeat += 1
	id := c.nextHeartbeat
	c.nextHeartbeatMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32((*p.Content).Len())
	c.inflightHeartbeatMu.Lock()
	c.inflightHeartbeat[id] = ch
	c.inflightHeartbeatMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case <-c.client.CloseChannel():
		err = c.client.Error()
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightHeartbeatMu.Lock()
	delete(c.inflightHeartbeat, id)
	c.inflightHeartbeatMu.Unlock()
	packet.Put(p)
	return
}

type CloseError struct {
	err error
}

func NewCloseError(err error) CloseError {
	return CloseError{err: err}
}

func (e CloseError) Error() string {
	return e.err.Error()
}
